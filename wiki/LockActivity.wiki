#summary Design information on our lockscreen replacement method

= What is a Lock Activity? =

In android 2.0, two window flags were added allowing activities to inherently interact with the lockscreen.
  * FLAG_SHOW_WHEN_LOCKED allows a window to get shown above the keyguard. It will only work with a non-translucent theme, even if you force fullscreen. It can only handle input from the user while awake. If asleep, no behavior change occurs, currently. When the window exits, the lockscreen immediately re-appears. It currently seems that one has to revert to the pre-2.0 lockscreen exit code while using this window if they wish for a seamless exit into another part of their app from this activity.
  * FLAG_DISMISS_KEYGUARD allows the window to get shown and cancel the keyguard completely. How this is different from the first flag is that when the activity is closed, the user will then see their last task in the stack instead of the lockscreen. If sleep occurs while activity is active, it also prevents the Keyguard from occurring where it would normally govern that sleep. This means any key will cause a wakeup, because the Keyguard is what mediates blocking wakeup from the side keys. There is no good way to get back to the lockscreen from this type of activity. However, we found that as long as we call DisableKeyguard from the pre-2.0 method at the same time as creating this activity to cancel, we can then use the corresponding Re-enable call that will actually cause the lockscreen to re-appear on demand.

= How do we make use of the Lock Activities to let the user customize their lockdown & wakeup experience? =
The implementation involves a life-cycle mediated by a remote service handling phone and screen events, which attempts to launch the Lock Activity at screen off. Two startCommand callbacks will be sent back to the mediator via simple implicit intent broadcasts, allowing it to know when the Lock Activity successfully started and when it successfully exited. This life cycle lets our activity pose as the lockscreen.

The real trickiness comes from the fact that key event mediation is not as we would expect with these lockscreen interaction flags. With show when locked, it seems we don't get any events unless awake. With dismiss, we get everything, and also have to deal with a wakeup from everything. The expected behavior for either would be the ability to handle key events first, then return false if we wanted to pass them on to the lockscreen for handling. It seems the case hasn't been considered, so the odd Always vs Never wake behavior is the end result.

Despite challenges, we've been able to create a custom lockscreen that comes on top of pattern security, one that is button customizable, and one that simply replaces the stock lockscreen without trying to reinvent the power control functionality. These are 3 basic modes- Secure, Guarded, and Advanced.

Secure happens on top of the lockscreen, regardless of whether there is a pattern. You have to slide the pattern or regular slider to get to anything else.

Guarded just replaces the lockscreen, automatically exiting it. These first two modes use show_when_locked.

Advanced is the trickiest, as it totally disables the lockscreen (utilizing dismiss_keyguard), allowing any button to wake it up. Various settings are available with it to determine which keys instant unlock and which are guarded so only lockscreen wakes. Additionally, advanced power saving can be enabled, allowing toggle of Locked mode for any key to keep the screen asleep in the case of a pocket-press, and optional shortened screen sleep time when a guarded key wakes the custom lockscreen. 